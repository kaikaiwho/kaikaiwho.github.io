<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  
<link rel="stylesheet" href="/lib/highlight/styles/github.css">

<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaikaiwho</title>
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>
  <body>
    <div id="container">
      <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <div class="blog-title">
                <a href="/" class="logo"><i class="logo-img">logo </i> Kaikaiwho</a>
            </div>
            <nav class="navbar">
                <ul class="menu">
                    
                    <li class="menu-item">
                      <a href="/" class="menu-item-link">首页</a>
                    </li>
                    
                    <li class="menu-item">
                      <a href="/archives" class="menu-item-link">归档</a>
                    </li>
                    
                    <li class="menu-item">
                      <a target="_blank" rel="noopener" href="https://github.com/kaikaiwho" class="menu-item-link">交友</a>
                    </li>
                    
                </ul>
            </nav>
        </div>   
    </div>
</header>
      <div class="outer">
        <aside id="left">
          <!-- 作者信息 -->
          
        </aside>
        <main class="main"> 
          <article id="article">
    <div class="post-title">
      <h2 class="title">js</h2>
    </div>
     <div class="post-meta">
      <span class="post-time">2020-12-28</span>
    </div>
    <div class="post-content">
      <h2>JS 跨域怎么做</h2>
<blockquote><p>什么是跨域？当一个请求url的 协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。</p>
<p>参考链接:<a target="_blank" rel="noopener" href='https://segmentfault.com/a/1190000011145364'>前端常见跨域解决方案（全）</a></p>
</blockquote>
<ol>
<li><p>JSONP (JSON with Padding)
通过动态创建 script，再请求一个带参网址实现跨域通信。</p>
<blockquote><p>参考链接：<a target="_blank" rel="noopener" href='https://segmentfault.com/a/1190000007665361#articleHeader1'>jsonp的原理与实现</a></p>
</blockquote>
</li>
<li><p>CORS (跨域资源共享)
CORS的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>
<p>普通跨域请求：只需服务端设置 <code>Access-Control-Allow-Origin</code> 即可，前端无须设置，若要带 cookie 请求：前后端都需要设置。前端设置<code>withCredentials</code>为true,后端设置<code>Access-Control-Allow-Credentials</code>为true,同时<code>Access-Control-Allow-Origin</code>不能设置为<code>*</code></p>
<p>目前，所有浏览器都支持该功能(IE8+；IE8/9 需要使用 XDomainRequest 对象来支持 CORS)，CORS 也已经成为主流的跨域解决方案。</p>
</li>
<li><p>window.postMessage
现代浏览器中多窗口通信使用 HTML5 规范的 targetWindow.postMessage(data, origin);其中 data 是需要发送的对象，origin 是目标窗口的 origin。window.addEventListener(&#39;message&#39;, handler, false);handler 的 event.data 是 postMessage 发送来的数据，event.origin 是发送窗口的 origin，event.source 是发送消息的窗口引用</p>
</li>
<li><p>服务器代理
内部服务器代理请求跨域 url，然后返回数据</p>
</li>
</ol>
<h2>JSONP 怎么实现的</h2>
<blockquote><p>JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。</p>
</blockquote>
<p>举个例子来说明具体情况：</p>
<p>前端代码</p>
<pre><code class='language-javascript' lang='javascript'>&lt;script&gt;
function test(data) &#123;
    console.log(data.name);
&#125;
&lt;/script&gt;
&lt;script src=&quot;http://127.0.0.1:8088/jsonp?callback=test&quot;&gt;&lt;/script&gt;
</code></pre>
<p>后端代码</p>
<pre><code class='language-javascript' lang='javascript'>res.end(&#39;test(&#123;&quot;name&quot;: &quot;Monkey&quot;&#125;)&#39;);
</code></pre>
<p>以上就实现了JSONP跨域，前端正常打印出了&quot;Monkey&quot;</p>
<p>请求JSONP之前就定义好回调函数test，后端返回的是调用test函数的js代码，浏览器加载这段代码后立即执行</p>
<h2>JOSNP 有什么优缺点</h2>
<p>缺点：</p>
<ol>
<li>它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求</li>
<li>它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。</li>
<li>JSONP 在调用失败的时候不会返回各种 HTTP 状态码。</li>
<li>安全性。假如提供 JSONP 的服务存在页面注入漏洞，即它返回的 JavaScript 的内容被人控制的。那么结果是什么？所有调用这个 JSONP 的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用 JSONP 的时候必须要保证使用的 JSONP 服务必须是安全可信的。</li>
</ol>
<p>优点：</p>
<ol>
<li>它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制，JSONP 可以跨越同源策略；</li>
<li>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持</li>
<li>在请求完毕后可以通过调用 callback 的方式回传结果。</li>
</ol>
<h2>new 运算符的过程</h2>
<ol>
<li>创建一个空对象{}；</li>
<li>构造函数中的 this 指向该空对象</li>
<li>执行构造函数为这个空对象添加属性</li>
<li>判断构造函数有没有返回值，如果返回值是个对象，则返回这个对象；否则返回创建的“空对象”</li>
</ol>
<h2>数组的 push() 和 pop() 方法的返回值是什么</h2>
<ul>
<li><code>push()</code>将一个或多个元素添加到数组的末尾，并返回该数组的新长度</li>
<li><code>pop()</code>方法从数组中删除最后一个元素，并返回该元素的值</li>
</ul>
<h2>JS 作用域</h2>
<p>ES5 只有全局作用域和函数作用域</p>
<ul>
<li>全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都存在全局作用域</li>
<li>函数作用域：在固定的代码片段才能被访问</li>
</ul>
<p>ES6 有块级作用域</p>
<h2>ES6 新特性</h2>
<ul>
<li>let const 块级作用域</li>
<li>模板字符串</li>
<li>解构赋值</li>
<li>箭头函数，函数参数默认值</li>
<li>扩展运算符（...）</li>
<li>forEach for...of for...in</li>
<li>数组方法map reduce includes</li>
<li>map和set</li>
<li>模块化</li>
<li>promise proxy</li>
<li>async</li>
<li>class</li>
</ul>
<h2>let 和 var 的区别</h2>
<ul>
<li>let 是块级作用域，var 是函数作用域</li>
<li>var 存在变量提升，而 let 没有</li>
<li>在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区” (TDZ)</li>
</ul>
<pre><code class='language-javascript' lang='javascript'>if (true) &#123;
  // TDZ开始
  tmp = &#39;abc&#39; // ReferenceError
  console.log(tmp) // ReferenceError
<p>let tmp // TDZ结束<br>
console.log(tmp) // undefined</p>
<p>tmp = 123<br>
console.log(tmp) // 123<br>
&#125;<br>
</code></pre></p>
<p>上面代码中，在 let 命令声明变量 tmp 之前，都属于变量 tmp 的“死区”。</p>
<h2>闭包的特性以及优缺点</h2>
<pre><code class='language-javascript' lang='javascript'>function test() &#123;
  var age = 18
  function  addAge()&#123;
    age++;
    alert(age)
  &#125;
  return addAge
&#125;
</code></pre>
<p>闭包有三个特性：</p>
<ul>
<li>函数嵌套函数；</li>
<li>内部函数使用外部函数的参数和变量；</li>
<li>参数和变量不会被垃圾回收机制回收。</li>
</ul>
<p>闭包的优点：</p>
<ul>
<li>希望一个变量长期保存内存中；</li>
<li>避免全局变量污染；</li>
<li>私有成员的存在。</li>
</ul>
<p>闭包的缺点：</p>
<ul>
<li>常驻内存，增加内存使用量；</li>
<li>使用不当造成内存泄漏。</li>
</ul>

    </div>
    <div class="comment">
      <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC81MjMwNS8yODc4Mw==">
    <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];
    
           if (typeof LivereTower === 'function') { return; }
    
           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;
    
           e.parentNode.insertBefore(j, e);
       })(document, 'script');
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>
    <!-- City版安装代码已完成 -->
    </div>
</article>
        </main>
      </div>
      <footer>
        <footer id="footer">
    <p class="support">
        <span class="theme">Theme by kaikaiwho |</span>
        <span class="hosted"> Hosted by kaikaiwho</span>
    </p>
    <p class="visitedNum">
        <span id="busuanzi_container_site_pv">
            总访问 <span id="busuanzi_value_site_pv"></span> 次
          </span>
    </p>
</footer>
      </footer>
    </div>
    
<script src="/lib/highlight/highlight.pack.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
  </body>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
</html>